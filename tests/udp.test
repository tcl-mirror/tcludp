# Commands covered:  udp_open udp_conf udp_peek
#
# This file contains a collection of tests for one or more of the Tcl
# UDP package commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2003 by Pat Thoyts <patthoyts@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: udp.test,v 1.7 2008/07/06 12:27:30 patthoyts Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

package require udp

# -------------------------------------------------------------------------

test udp-1.0 {udp_open with any port} -body {
    set s [udp_open]
} -cleanup {
    close $s
} -match regexp -result {sock\d+}

test udp-1.1 {udp_conf -myport} -setup {
    set s [udp_open]
} -body {
    udp_conf $s -myport
} -cleanup {
    close $s
} -match regexp -result {^\d+$}

test udp_1.3 {fconfigure -myport} -setup {
    set s [udp_open]
} -body {
    fconfigure $s -myport
} -cleanup {
    close $s
} -match regexp -result {^\d+$}

test udp-1.4 {udp_open on assigned port} -body {
    set port 0xf0b0
    set s [udp_open $port]
    format 0x%04x [udp_conf $s -myport]
} -cleanup {
    close $s
} -result {0xf0b0}

test udp-1.5 {udp_conf -remote before seting remote details} {
    list [catch {
        set s [udp_open]
        set r [udp_conf $s -remote]
        close $s
        set r
    } msg] $msg
} {0 {}}

test udp-1.6 {udp_conf -peer before setting remote details} {
    list [catch {
        set s [udp_open]
        set r [udp_conf $s -peer]
        close $s
        set r
    } msg] $msg
} {0 {}}


test udp-2.0 {udp_conf using service name} {
    list [catch {
        set s [udp_open]
        udp_conf $s localhost ntp
        set r [udp_conf $s -remote]
        close $s
        set r} msg] $msg
} {0 {localhost 123}}

test udp-2.1 {udp_conf using service number} {
    list [catch {
        set s [udp_open]
        udp_conf $s localhost 123
        set r [udp_conf $s -remote]
        close $s
        set r} msg] $msg
} {0 {localhost 123}}

test udp-2.2 {udp_open on named port} {pcOnly} {
    list [catch {
        set port ntp
        set s [udp_open $port]
        set check [udp_conf $s -myport]
        close $s
        format 0x%04x $check
    } msg] $msg
} {0 0x007b}

test udp-3.0 {test -mcastadd} -setup {
    set s [udp_open]
} -body {
    fconfigure $s -mcastadd 224.0.10.10
} -cleanup {
    close $s
} -result {224.0.10.10}

test udp-3.1 {test -mcastadd} -setup {
    set s [udp_open]
} -body {
    fconfigure $s -mcastadd 224.0.10.10
    fconfigure $s -mcastadd 224.0.10.11
} -cleanup {
    close $s
} -result {224.0.10.10 224.0.10.11}

test udp-3.2 {test -mcastadd} -setup {
    set s [udp_open]
} -body {
    set a [fconfigure $s -mcastadd 224.0.10.10]
    set a [fconfigure $s -mcastadd 224.0.10.11]
} -cleanup {
    close $s
} -result {224.0.10.10 224.0.10.11}

test udp-3.3 {test -mcastdrop} -setup {
    set s [udp_open]
} -body {
    fconfigure $s -mcastadd 224.0.10.10
    fconfigure $s -mcastadd 224.0.10.11
    fconfigure $s -mcastdrop 224.0.10.11
} -cleanup {
    close $s
} -result {224.0.10.10}

test udp-3.4 {test -mcastdrop} -setup {
    set s [udp_open]
} -body {
    set a [fconfigure $s -mcastadd 224.0.10.10]
    set a [fconfigure $s -mcastadd 224.0.10.11]
    set a [fconfigure $s -mcastdrop 224.0.10.11]
} -cleanup {
    close $s
} -result {224.0.10.10}

test udp-3.5 {join invalid multicast group} -setup {
    set s [udp_open]
} -body {
    fconfigure $s -mcastadd 192.168.0.1
} -cleanup {
    close $s
} -returnCodes error -match glob -result {*}

test udp-3.6 {drop invalid multicast group} -setup {
    set s [udp_open]
} -body {
    fconfigure $s -mcastdrop 192.168.0.1
} -cleanup {
    close $s
} -returnCodes error -match glob -result {*}

test udp-3.7 {-mcastloop invalid option} -setup {
    set s [udp_open]
} -body {
    fconfigure $s -mcastloop stupid
} -cleanup {
    close $s
} -returnCodes error -match glob -result {expected boolean value *}

test udp-3.8 {-mcastloop is boolean - 1/0} -setup {
    set s [udp_open]
} -body {
    set a [list [fconfigure $s -mcastloop 1]]
    lappend a [fconfigure $s -mcastloop 0]
    set a
} -cleanup {
    close $s
} -result {1 0}

test udp-3.9 {-mcastloop is boolean - true/false} -setup {
    set s [udp_open]
} -body {
    set a [list [fconfigure $s -mcastloop true]]
    lappend a [fconfigure $s -mcastloop false]
    set a
} -cleanup {
    close $s
} -result {1 0}

test udp-3.10 {-mcastloop is boolean - yes/no} -setup {
    set s [udp_open]
} -body {
    set a [list [fconfigure $s -mcastloop yes]]
    lappend a [fconfigure $s -mcastloop no]
    set a
} -cleanup {
    close $s
} -result {1 0}

test udp-3.11 {-mcastloop is boolean - on/off} -setup {
    set s [udp_open]
} -body {
    set a [list [fconfigure $s -mcastloop on]]
    lappend a [fconfigure $s -mcastloop off]
} -cleanup {
    close $s
} -result {1 0}



test udp-10.1 "bug #1838467 - crash on exit" -setup {
    set s [udp_open]
} -body {
    # Note: this test actually causes a crash on process exit when it
    # fails. The socket needs to be left open ...
    fconfigure $s -mcastadd 224.0.10.10
    fconfigure $s -mcastadd 224.0.10.11
    fconfigure $s -mcastadd 224.0.10.12
} -cleanup {
    # close $s - not closed on purpose
} -result {224.0.10.10 224.0.10.11 224.0.10.12}

# -------------------------------------------------------------------------
# cleanup
catch {unset _udp}
::tcltest::cleanupTests
return

# Local variables:
# mode: tcl
# indent-tabs-mode: nil
# End:
